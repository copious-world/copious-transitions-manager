<!doctype html>
<html>
<head>
	

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="author" content="$AUTHOR" />
<meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
<meta id="theme-color" name="theme-color" content="#452770">

<link rel="canonical" href="http://www.copious.world">

<title>Copious World</title>
<meta name="description" content="An entry point into the our world of AI, IoT, and Communities built around songs, etc.">

	<link rel='icon' type='image/png' href='./favicon.png'>
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,600,700" />
	<link rel='stylesheet' href='./global.css'>
	<link rel='stylesheet' href='./build/bundle.css'>

	<script defer src='./build/bundle.js'></script>
</head>
<style>

/*csslint important:false*/

body {
	height: 100%;
}

/**
* Always hide an element when it has the `hidden` HTML attribute.
*/

.hidden,
[hidden] {
	display: none !important;
}

/**
* Add this class to an image to make it fit within it's fluid parent wrapper while maintaining
* aspect ratio.
*/
.pure-img {
	max-width: 100%;
	height: auto;
	display: block;
}


.fitMenuLower {
	width: 95%;
	height: 50%;
	margin-left:0px;
	margin-right:0px;
	padding: 8px;
	margin-top:8px;
	background: -webkit-linear-gradient(to right, white, #FAFAFF);
	background: linear-gradient(to right, white, #FAFAFF );
	margin-left: 10px;
}

#squashMenu:hover {
	border: 1px solid rgb(230,230,240,0.4);
	padding-top:4px;
	background-color: #EFEFEF;
}

#squashMenuContainer {
	position:absolute;
	visibility:hidden;
	top : 0; left : 0;
	height:100%;
	width: 55%;
	z-index:100;
	border: rgba(252, 190, 190, 0.4) 2px solid;
	background-color: white;
}

#thankyou_box {
	position:absolute;
	visibility:hidden;
	top : 25%; left : 25%;
	height:50%;
	width: 50%;
	z-index:150;
	border: rgba(100, 5, 5, 0.6) 2px solid;
	background-color: lightgoldenrodyellow;
	overflow: auto;
}

button {
	cursor: pointer;
	font-size: 101%;
	font-weight: bold;
	color: darkblue;
	margin: 2px;
	width:120px;
}

button:hover {
	background-color : #CACAFF;
	color: darkred;
}


body {
	border: 1px solid black;
	
	-moz-box-sizing: border-box;
	box-sizing: border-box;
}


@media screen and (orientation: portrait) {
	#mainNav {
		width: 100%;
	}
}

@media screen and (orientation: landscape) {
	#mainNav {
		width: 100%;
	}
}

main {
	border-left: solid 3px navy;
	border-top: solid 1px #8833BB;
	padding : 4px;
}

#mainNav {
	font-family: 'Montserrat', 'Helvetica Neue', Helvetica, Arial, sans-serif;
	font-weight: 700;
	text-transform: uppercase;
	background: blue;
	border-left: solid 3px navy;
	border-top: solid 3px navy;
	border-bottom: solid 3px rgba(252,252,255,0.7);
	min-height: 90px;
	padding: 20px;
	background: -webkit-linear-gradient(to left, rgba(242, 242, 210, 0.3), white);
	background: linear-gradient(to left, rgba(242, 242, 210, 0.3), white );
	
}

#mainNav table {
	padding-left: 3%;
}

#mainNav  table  a:focus { outline: none; }
#mainNav  table  .navbar-brand {
	font-size: 1.1rem;
	color: white;
}

#mainNav  table  .navbar-brand.active, #mainNav .navbar-brand:active, #mainNav .navbar-brand:focus, #mainNav .navbar-brand:hover {
	color: white;
}

#mainNav  table  .navbar-nav {
	letter-spacing: 1px; }

#mainNav  table  .navbar-nav li.nav-item {
	display:inline;
}

#mainNav  table  .navbar-nav li.nav-item a.nav-link {
	color: darkgreen;
	text-decoration: none;
	vertical-align: top;
	padding-right: 10px;
}

#mainNav  table  .navbar-nav li.nav-item a.nav-link:hover {
	color: #18BC9C;
	outline: none;
	
}

#mainNav  table  .navbar-nav a.nav-text {
	background-color : rgba(242,222,255,0.6);
	border-radius: 25px;
	margin-bottom: 9px;
	margin-right: 6px;
	white-space: nowrap;
}

#mainNav  table  .navbar-nav li.nav-item a.nav-link:active, #mainNav .navbar-nav li.nav-item a.nav-link:focus { color: white; }

.footer-list li {
	list-style-type: none;
}

.footer-list li a:hover { color: gold; }

footer {
	padding:10px;
	background: -webkit-linear-gradient(to left, rgba(252,252,255,0.5), #fffbe2 );
	background: linear-gradient(to left, rgba(252,252,255,0.5), #fffbe2  );
	text-align: center;
	font-size: 0.85em;
}

footer a {
	text-decoration:none;
	color:darkgreen;
	font-weight:bold;
	font-style: italic;
}

.copiouslink:hover {
	fill:navy;
}
.copiouslink {
	fill:black;
}

* {margin: 0; padding: 0; box-sizing: border-box}

.PhIOtjDr_0 {
	fill:none;
	stroke:#1c1448;
	stroke-width:4.59875107;
	stroke-miterlimit:4;
	stroke-dasharray: 2948 2950;
	stroke-dashoffset: 2949;
	animation: PhIOtjDr_draw 6666ms ease-in forwards;
}

@keyframes PhIOtjDr_draw {
	100% {stroke-dashoffset: 0}
}

@keyframes PhIOtjDr_fade {
	0% {stroke-opacity: 1}
	97.1830985915493% {stroke-opacity: 1}
	100% {stroke-opacity: 0}
}

label {
	font-weight:bold;
	color:darkgreen;
	width:35%;
}

.error-message {
	visibility:hidden;
	width:75%;
	font-weight:bolder;
	color:red;
	background-color:white;
	border: solid 1px orange;
	padding:2px;
	margin:3px;
}

/* The Close Button */
.close {
	color: white;
	float: right;
	font-size: 18px;
	font-weight: bold;
}

.close:hover,
.close:focus {
	color: #000;
	text-decoration: none;
	cursor: pointer;
}

/* Add Animation */
@-webkit-keyframes slideIn {
	from {bottom: -300px; opacity: 0}
	to {bottom: 0; opacity: 1}
}

@keyframes slideIn {
	from {bottom: -300px; opacity: 0}
	to {top: 0; opacity: 1}
}

@-webkit-keyframes fadeIn {
	from {opacity: 0}
	to {opacity: 1}
}

@keyframes fadeIn {
	from {opacity: 0}
	to {opacity: 1}
}

.no-view-file-field {
	display: none;
	visibility: hidden;
}

h2 {
	text-transform: capitalize;
	color:#4ca85c;
	font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
}


#active-user-title {
	font-size: 95%;
	font-style: oblique;
	font-weight: bold;
	margin: 2%;
	color: goldenrod;
}
</style>
<script>
	var g_siteURL = window.location.host;
	var g_finalizers = []
	var g_loginStateViewHolders = {}
</script>
<body>

<nav id="mainNav">
	<table style="width:100%">
		<tr>
			<td style="width:62;height:63">
				<a class="nav-link" href="/"  target="http://www.copious.world-again" >
											    <svg version="1.0" width="60" height="60" viewBox="0 0 250 250" preserveAspectRatio="xMidYMid meet" id="logo" >
								<defs id="defs10"/>
								<path class="PhIOtjDr_0"  id="path6" d="m 30.107062,7.4672872 c 4.67725,2.6985208 8.37554,8.6930958 12.94402,20.5087688 7.17904,19.072767 24.58277,67.337762 29.69511,82.950634 l 5.32989,15.9502 -13.70543,-0.25058 -10.468161,2.57106 -8.132079,2.99946 -4.78602,5.90784 0.76141,-6.91979 c 0.65264,-6.50536 0.32632,-7.85462 -5.43866,-25.31791 C 27.822822,80.549048 20.535012,60.127019 12.703332,40.215781 5.4155222,21.730904 4.4365622,15.57249 7.8085322,10.503124 11.941922,4.43145 22.384152,2.9954505 30.107062,7.4672872 Z M 238.08162,22.742849 c 3.69828,2.110631 6.52639,6.669206 6.52639,10.379672 0,1.686578 -2.93688,12.740881 -6.63517,24.469814 -19.68797,64.138095 -30.34775,107.931245 -30.34775,124.806655 0,4.6453 -1.08775,7.68113 -18.60024,50.80931 l -4.35093,10.79409 -67.76577,0 -67.765758,0 -14.35808,-35.35063 -14.35808,-35.3603 17.62128,-20.75934 17.5125,-20.75935 29.36879,0 c 32.631998,0 5.455822,5.28877 29.390108,7.16797 -3.81133,6.98972 7.16732,11.29772 7.16732,11.29772 l 2.51778,3.43975 c -1.74038,3.20932 -4.92039,6.69891 -9.3801,9.5709 l -3.2632,2.11064 -9.78959,-2.62144 c -8.593088,-2.27446 -11.312428,-2.61179 -22.080978,-2.61179 -13.0528,-0.0964 -14.35808,0.2506 -14.35808,4.29837 0,2.70817 3.15443,3.63336 12.72648,3.63336 21.42834,0 38.723308,8.01847 47.533928,22.10863 3.58951,5.73436 7.17904,15.86345 7.17904,20.50876 0,2.86236 4.45971,5.05973 7.50536,3.79721 2.82811,-1.09868 2.93687,-4.64531 0.65264,-14.01306 -2.28424,-9.36772 -7.83169,-17.88734 -15.77214,-24.29632 -5.32988,-4.30799 -6.30884,-5.49342 -5.11233,-6.24517 1.19649,-0.76135 2.06669,-0.51077 4.0246,1.08906 6.30885,5.23321 19.03534,7.00654 27.73719,3.88395 5.87377,-2.11064 11.85631,-7.17036 15.11951,-12.74088 1.52281,-2.53468 5.98253,-16.03694 9.89835,-29.9536 10.98611,-38.396111 22.08098,-72.320389 30.13021,-92.665317 5.54744,-14.176879 12.40016,-19.737762 23.16871,-18.812555 2.93688,0.250577 6.63517,1.175785 8.15801,2.023891 z m -126.72091,50.03831 c 2.28424,0.510792 5.76499,2.11063 7.72291,3.633367 5.87375,4.558576 6.20008,7.257098 3.80705,29.278954 -1.1965,10.71701 -1.94404,26.93071 -2.27035,27.1042 -0.32632,0.25057 -8.38942,-6.50868 -17.41761,-6.25812 l -16.533538,0.42407 0.65264,-6.66922 c 0.32632,-3.62372 1.19651,-13.83956 1.84915,-22.619385 0.65264,-9.19425 1.74037,-17.125977 2.50179,-18.561977 3.2632,-5.907835 10.550998,-8.269041 19.687958,-6.331889 z m 48.5129,9.454465 c 2.06668,1.011946 4.56848,3.209314 5.54744,4.89589 1.84914,2.871998 1.84914,4.22126 -0.8702,33.750816 -1.52282,17.04886 -3.37196,32.575 -4.24216,35.02295 -3.15442,8.51961 -9.13695,13.07819 -18.16513,13.67573 -4.78601,0.25056 -6.41762,0 -9.46327,-1.69622 -5.87376,-3.12256 -6.41764,-4.29838 -2.93689,-7.42094 6.20008,-5.744 4.00097,-11.09854 1.92352,-15.89687 0,0 -0.33391,-1.79223 -2.65798,-4.24016 l -2.01123,-1.92782 3.94219,-26.79768 c 1.95792,-22.869967 2.17547,-23.795174 5.11237,-26.667174 4.89478,-4.89589 16.96861,-6.24515 23.82134,-2.698522 z" />
								<rect style="fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:4.80000019;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" id="rect4169" width="68.005806" height="55.413109" x="62.964886" y="157.3824"/>
								<rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:1.60000002;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" id="rect4170" width="39.957146" height="46.691494" x="105.05587" y="172.33051"/>
								<rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" id="rect4172" width="134.35677" height="7.9790406" x="49.16119" y="238.93228"/>
								<text xml:space="preserve" style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:184.28874207px;line-height:125%;font-family:'Arial Rounded MT Bold';-inkscape-font-specification:'Arial Rounded MT Bold, Normal';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#0000ff;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" x="6.6644416" y="260.41125" id="text4161" transform="scale(1.041834,0.95984582)"><tspan id="tspan4163" x="6.6644416" y="260.41125">C</tspan></text>
								<text xml:space="preserve" style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:28.53204727px;line-height:125%;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#ff0000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" x="90" y="175.07523" id="text4165" transform="scale(0.90874022,1.1004245)"><tspan id="tspan4167" x="90" y="175.07523">opious</tspan></text>
							</svg>

				</a>
			</td>
			<td>
				<ul class="navbar-nav">
					<li class="nav-item">
						<a class="nav-link" href="https://github.com/copious-world" target="GitGHub" >
							<svg role="img" width="30" height="30"  preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<title>GitHub copious-world</title>
<path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/>
</svg>

						</a>
					</li>
					<li id="squashMenu"   class="nav-item" style="visibility:hidden;cursor:pointer" onmousedown="menuHandler(this)" onmouseup="releaseMenu(this)">
						$file::mushroom-menu-icon.svg<<
					</li>
				</ul>
			</td>
			<td style="text-align: center;">
				<h2></h2> 
				<span id="active-user-title">ucwid</span>  :: ----
			</td>
			<td>
				&nbsp;
			</td>
		</tr>
	</table>
</nav>

	<main id='app-main'>
	
	</main>
	<div style="visibility: hidden;">
		<a id='identity-download-link' href = "" >identity download</a>
		<input class="no-view-file-field" type="file" id="drop-click-file_loader" />
	</div>

<footer>
	<ul class="footer-list">
		<li>
			<a href="http://www.copious.world" target="http://www.copious.world-again">copyright &copy; 2022 copious.world</a>
			<span class="status-style" id="page-error-message">status: good</span>
		</li>
	</ul>
</footer>

</body>
</html>
<script>

// ---- ---- ---- ---- ---- ----  ---- ---- ---- ---- ---- ----  ---- ---- ---- ---- ---- ----  ---- ---- ---- ---- ---- ----
// SHARED CONSTANTS


// SITE PAGE
//
const SITE_PAGE_TO_FRAME = "site_page_to_frame"
const SITE_PAGE_TO_BUILDER = "site_page_to_builder"
const SITE_PAGE_TO_ALL = "RELAY"
const SITE_RELATES_TO_BUILDER = "site_page_request_id"
const SITE_RELATES_TO_FRAME = "site_page_request_action"
const SITE_RELATES_TO_ALL = "site_frame_yields_news"

// FRAME PAGE
const FRAME_PAGE_TO_HOSTED_APP = "frame_page_to_hosted_app"
const FRAME_PAGE_TO_SITE = "frame_page_to_site"
const FRAME_PAGE_TO_BUILDER = "frame_page_to_builder"
const FRAME_PAGE_TO_SERVICE_WORKER = "frame_page_to_sw"
const FRAME_PAGE_TO_WORKER = "frame_page_to_w"
const FRAME_PAGE_RELATES_TO_SITE = "frame_page_injector"
const FRAME_PAGE_RELATES_TO_BUILDER = "frame_page_reponses"
const FRAME_PAGE_RELATES_TO_SERVICE_WORKER = "frame_page_shared_action"
const FRAME_ACTION_TO_APP = "frame_page_request_action"
const FRAME_REQUEST_SESSION = "frame_page_request_session"
const FRAME_ACTION_FROM_APP = "hosted_app_requests_action"

// APP PAGE
//
const HOSTED_APP_TO_FRAME = "hosted_app_to_frame"
const HOSTED_APP_TO_ALL = "RELAY"
const APP_RELATES_TO_FRAME = "app_in_human_context"
const APP_RELATES_TO_ALL = "app_in_frame_yields_news"

// BUILDER PAGE
//
const BUILDER_PAGE_TO_FRAME = "builder_page_to_frame"
const BUILDER_PAGE_TO_SITE = "builder_page_to_site"
const BUILDER_RELATES_TO_SITE = "builder_page_injector"
const BUILDER_ACTION_TO_FRAME = "builder_page_request_action"

// HUMAN FRAME WORKER
const WORKER_TO_FRAME = "worker_to_frame"
const WORKER_RELATES_TO_FRAME = "worker_request_action"


//
// actions
const FRAME_COMPONENT_RESPOND = "respond"
const FRAME_COMPONENT_RESPONDING = "responding"
const FRAME_ACTION_LOAD_APP = "load-app"
const FRAME_ACTION_INSTALL = "install-id"
const FRAME_ACTION_INJECT = "inject"
const FRAME_START_SESSION = "start-session"
const FRAME_HAS_SESSION = "has-session"
const FRAME_NEEDS_SIGNATURE = "get-signature"
const FRAME_WANTS_SESSION = "get-session"
const FRAME_STOP_SESSION = "stop-session"
const FRAME_HAS_PERSONALIZATION = "has-personalization"
const SITE_WANTS_SIGNATURE = "send-sig-remote"


const MANAGER_PAGE_TO_FRAME = "from-manager-to-frame"
const ID_MANAGER_ACTION_TO_FRAME = "id-presence-manager"
const FRAME_ACTION_REMOVE = "id-manager-remove-id"
const FRAME_ACTION_UPLOAD = "id-manager-upload-id"
const FRAME_ACTION_DOWNLOAD = "id-manager-download-id"
const FRAME_ACTION_DOWNLOAD_PUBLIC = "id-manager-download-public-intro"
const FRAME_MANAGE_PICTURE_ASSET = "manager-picture-asset"
const FRAME_ACTION_ATTACH = "manager-asset-attach"


// categories
const FRAME_COMPONENT_SAY_ALIVE = "q-alive"
const FRAME_COMPONENT_MANAGE_ID = "m-igid"
const HOST_APP_PERSONALIZATION = "personalization"
const FRAME_TO_APP_PUBLIC_COMPONENT = "process-public-info"
const SITE_TO_FRAME_SESSIONS = "transfer-session"
const FRAME_TO_SITE_MANAGE_SESSION = "site-manage-session"
const WORKER_TO_FRAME_SESSIONS = "w-transfer-session"
const FRAME_WORKER_TO_SESSIONS = "transfer-session"
const FRAME_TO_HOSTED_APP_SESSIONS = "transfer-session"
const FRAME_TO_APP_SIGNATURE = "signed-data"
const FRAME_SIGNED = "yep-signed"

//
let g_user_current_session = false
let g_current_user_id = false
let g_current_user_name = false
let g_current_pub_identity = false


const g_message_template =  {
                                "category" : "",
                                "direction" : "",
                                "action" : "",
                                "relationship" : ""
                            }




// MODULE: PC LOCATION (windowized)



//$>>	pc_getLocation

function pc_getLocation() {
    if (navigator.geolocation) {
      let loc_display = document.getElementById("wv-geo-location");
      navigator.geolocation.watchPosition((position) => {  // watch position updates location at a system defined interval
        if ( loc_display ) loc_display.innerHTML = `${position.coords.latitude},${position.coords.longitude}`
        g_pc_current_locaion = { "latitude" : position.coords.latitude, "longitude" : position.coords.longitude }  // clone
        pc_update_geo_location(g_pc_current_locaion)
      });
    } else { 
      alert("Geolocation is not supported by this browser.");
    }
  }
  
  



//$EXPORTABLE::
/*
pc_getLocation
*/


// MODULE: common (windowized)


//$>>	ext_of_file
function ext_of_file(file_name) {
	let idx = file_name.lastIndexOf('.')
	let ext = file_name.substr(idx+1)
	return ext
}

//$>>	clonify
function clonify(obj) {
	if ( typeof obj === 'string' ) return(obj)
	try {
		let out = JSON.parse(JSON.stringify(obj))
		return(out)
	} catch(e) {
		return(null)
	}
}

//$>>	launch_simple_link
//                                                  <<depends>> errorMessage
function launch_simple_link(default_url,window_name) {
	let launched = window.open(`https://${default_url}/`,window_name)
	if ( !launched ) {
		errorMessage(`could not open window or tab for link ${default_url}`)
	}
}



//$EXPORTABLE::
/*
ext_of_file
clonify
addscript
addstyle,
launch_simple_link
*/



// MODULE: HTTPS CHECKS (windowized)

//$>>	not_https_switch
// switch to HTTPS before doing any ops that may require a data exchange
function not_https_switch() {
	if (location.protocol !== 'https:') {           // start from a secure page
		//alert("Switching to a secure version of this page in 1sec.")
		//setTimeout(()=> {location.replace(`https:${location.href.substring(location.protocol.length)}`)},1000)
		return(true)
	}
	return(false)
}


//$>>	getCookie
// simple check on cookies, searching by ';' delimited string with the cookie name at the start of the trimmed line.
function getCookie(cname) {  // modified from w3school
	var name = cname + "=";
	var ca = document.cookie.split(';');
	for(let i = 0; i < ca.length; i++) {
		var c = ca[i];
		if ( typeof c === 'string' ) {
			c = c.trim()
			if (c.indexOf(name) == 0) {
				return c.substring(name.length);
			}
		}
	}
	return "";
}



//$EXPORTABLE::
/*
not_https_switch
getCookie
*/



// MODULE: POST FETCH (windowized)

//$>>	postData
// //
//  call fetch with method POST tyr to help with parameters..  If data is FromData set do_stringify to false
//  default content type 'application/json'
//  User 'cors', Default cres = omit, If ctype == 'multipart/form-data' be sure to use FormData -- lets fetch set content type.
//  RETURNS: parsed JSON object or an empty object. ... Check for fields
//
async function postData(url = '', data = {}, creds = 'omit', do_stringify = true,ctype) {
	let content_type = 'application/json'
	if ( ctype !== undefined ) {
		content_type = ctype            // ctype is content type
	}
	let options = {
		method: 'POST', // *GET, POST, PUT, DELETE, etc.
		mode: 'cors', // no-cors, *cors, same-origin
		cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
		credentials: creds, // include, *same-origin, omit
		headers: {
			'Content-Type': content_type
		},
		redirect: 'follow', // manual, *follow, error
		referrerPolicy: 'no-referrer', // no-referrer, *client
		body: (do_stringify ? JSON.stringify(data)  : data)	// body data type must match "Content-Type" header
	}

	if ( ctype === 'multipart/form-data') {
		delete options.headers['Content-Type']  // content type will be set automatically with a boundary
	}

	// Default options are marked with *
	const response = await fetch(url, options);
	if ( response.ok == false ) {
		console.log(response.status + ': ' + response.statusText)
		return {}
	} else {
		return await response.json(); // parses JSON response into native JavaScript objects
	}
}

//$>>	fetchUrl
// //
// fetch with GET method
async function fetchUrl(endpoint) {
	let myRequest = new Request(endpoint);
	try {
		const body = await fetch(myRequest, {
									method: 'GET', // *GET, POST, PUT, DELETE, etc.
									mode: 'cors', // no-cors, *cors, same-origin
									cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
									credentials: 'omit', // include, *same-origin, omit
									redirect: 'follow', // manual, *follow, error
									referrerPolicy: 'no-referrer', // no-referrer, *client
								});
		//
		let infoObj = await body.json();
		return(infoObj)
		//
	} catch (e) {
		console.log(e.message)
		return(false)
	}
}


//$EXPORTABLE::
/*
fetchEndPoint
fetchUrl
postData
*/

// ---- ---- ---- ---- ---- 


// MODULE: base64 (windowized)

/*
MIT License

Copyright (c) 2020 Egor Nepomnyaschih

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/*
// This constant can also be computed with the following algorithm:
const base64abc = [],
	A = "A".charCodeAt(0),
	a = "a".charCodeAt(0),
	n = "0".charCodeAt(0);
for (let i = 0; i < 26; ++i) {
	base64abc.push(String.fromCharCode(A + i));
}
for (let i = 0; i < 26; ++i) {
	base64abc.push(String.fromCharCode(a + i));
}
for (let i = 0; i < 10; ++i) {
	base64abc.push(String.fromCharCode(n + i));
}
base64abc.push("+");
base64abc.push("/");
*/

//$>>	bytesToBase64

const base64abc = [
	"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
	"N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
	"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
	"n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
	"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"
];

const base64abc_url = [
	"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
	"N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
	"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
	"n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
	"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-", "_"
]

/*
// This constant can also be computed with the following algorithm:
const l = 256, base64codes = new Uint8Array(l);
for (let i = 0; i < l; ++i) {
	base64codes[i] = 255; // invalid character
}
base64abc.forEach((char, index) => {
	base64codes[char.charCodeAt(0)] = index;
});
base64codes["=".charCodeAt(0)] = 0; // ignored anyway, so we just need to prevent an error
*/
const base64codes = [
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63,
	52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255,
	255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
	15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255,
	255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
	41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
];

const url_alternates = "-_"
const plus_alt = url_alternates.charCodeAt(0)
const slash_alt = url_alternates.charCodeAt(1)

function getBase64Code(charCode) {
	if ( plus_alt === charCode ) {
		return 62
	}
	if ( slash_alt === charCode ) {
		return 63
	}
	if (charCode >= base64codes.length) {
		throw new Error("Unable to parse base64 string.");
	}
	const code = base64codes[charCode];
	if (code === 255) {
		throw new Error("Unable to parse base64 string.");
	}
	return code;
}

function bytesToBase64(bytes,url_no) {
	let apha = url_no ? base64abc : base64abc_url
	let result = '', i, l = bytes.length;
	for (i = 2; i < l; i += 3) {
		result += apha[bytes[i - 2] >> 2];
		result += apha[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
		result += apha[((bytes[i - 1] & 0x0F) << 2) | (bytes[i] >> 6)];
		result += apha[bytes[i] & 0x3F];
	}
	if (i === l + 1) { // 1 octet yet to write
		result += apha[bytes[i - 2] >> 2];
		result += apha[(bytes[i - 2] & 0x03) << 4];
		result += "==";
	}
	if (i === l) { // 2 octets yet to write
		result += apha[bytes[i - 2] >> 2];
		result += apha[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
		result += apha[(bytes[i - 1] & 0x0F) << 2];
		result += "=";
	}
	return result;
}

//$>>	base64ToBytes

function base64ToBytes(str) {
	if (str.length % 4 !== 0) {
		throw new Error("Unable to parse base64 string.");
	}
	const index = str.indexOf("=");
	if (index !== -1 && index < str.length - 2) {
		throw new Error("Unable to parse base64 string.");
	}
	let missingOctets = str.endsWith("==") ? 2 : str.endsWith("=") ? 1 : 0,
		n = str.length,
		result = new Uint8Array(3 * (n / 4)),
		buffer;
	for (let i = 0, j = 0; i < n; i += 4, j += 3) {
		buffer =
			getBase64Code(str.charCodeAt(i)) << 18 |
			getBase64Code(str.charCodeAt(i + 1)) << 12 |
			getBase64Code(str.charCodeAt(i + 2)) << 6 |
			getBase64Code(str.charCodeAt(i + 3));
		result[j] = buffer >> 16;
		result[j + 1] = (buffer >> 8) & 0xFF;
		result[j + 2] = buffer & 0xFF;
	}
	return result.subarray(0, result.length - missingOctets);
}

//$>>	base64encode

function base64encode(str, encoder = new TextEncoder()) {
	return bytesToBase64(encoder.encode(str));
}

//$>>	base64decode

function base64decode(str, decoder = new TextDecoder()) {
	return decoder.decode(base64ToBytes(str));
}


//$EXPORTABLE::
/*
bytesToBase64
base64ToBytes
base64encode
base64decode
*/





// MODULE: CRYPTO HASH (windowized)

// >> import


//<<
let base64 = window
//$>>	do_hash_buffer
async function do_hash_buffer(text) {
    const encoder = new TextEncoder();
    const data = encoder.encode(text);
    const hash = await g_crypto.digest('SHA-256', data);
    return hash
}

//$>>	do_hash
async function do_hash(text) {
    let buffer = await do_hash_buffer(text)
    const hashArray = Array.from(new Uint8Array(buffer));
    return base64.bytesToBase64(hashArray)
}

//$>>	from_hash
function from_hash(base64text) {
    let bytes = base64.base64ToBytes(base64text)
    return bytes
}

//$>>	to_base64
function to_base64(text) {
    return base64.base64encode(text)
}

//$>>	from_base64
function from_base64(base64text) {
    let bytesAsText = base64.base64decode(base64text)
    return bytesAsText
}

//$>>	from_base64_to_uint8array
function from_base64_to_uint8array(base64text) {
    while ( base64text.length %4 ) base64text += '='
    return base64.base64ToBytes(base64text)
}

//$>>	to_base64_from_uint8array
function to_base64_from_uint8array(a_uint8Array) {
    let b = base64.bytesToBase64(a_uint8Array)
    b = b.replace(/\=/g,'')
    return b
}

//$EXPORTABLE::
/*
do_hash_buffer
do_hash
from_hash
to_base64
from_base64
from_base64_to_uint8array
to_base64_from_uint8array
*/



//



if ( window.g_crypto === undefined ) {
    window.g_crypto = window.crypto ? window.crypto.subtle : null
    if ( g_crypto === null  ) {
      alert("No cryptography support in this browser. To claim ownership of assets, please use another browser.")
    }
    
}

/*
// gen_nonce
// Parameters: optional parameter
// 	--	no parameter case
// 	--	generate a random vaue -- return it as string
// 	--	parameter (optional) : A base64url string that is at least 16 bytes
//		-- returns the the first bytes as a base64url string (for deriving an IV from data) Not random
// 
// Returns a nonce as a base64url string representing 16 bytes = 128 bits
*/
function gen_nonce(input_bits) {
	if ( input_bits === undefined ) {
		let random = window.crypto.getRandomValues(new Uint8Array(16))
		return to_base64_from_uint8array(random)
	} else {
		let bytes = from_base64_to_uint8array(input_bits)
		bytes = bytes.subarray(0, 16)
		return to_base64_from_uint8array(bytes)
	}
}


/*
// gen_cipher_key
//    -- generates an AES key "AES-CBC",256 for encrypting and decrypting
// Returns: aes_key as a CryptoKey structure (see crypto.subtle.generateKey)
*/
async function gen_cipher_key() {
	//
	try {
		let aes_key = g_crypto.generateKey({
												name: "AES-CBC",
												length: 256
											},
											true,
											["encrypt", "decrypt"]
										)	

		return aes_key
	} catch(e){}
	//
	return false
}


//>--
// pc_keypair_promise
// Parameters: no parameters
// Returns: a Promise that resolves to an elliptic curve key using P-384 with sign and verify privileges
//  -- 
function pc_keypair_promise() {  // return
    // Generate a local public/private key pair
    let p =  g_crypto.generateKey({
            'name': "ECDSA",
            'namedCurve': "P-384"
        },
        true,
        ["sign", "verify"]
    )
    return p  // promise
}
//-


//>--
// axiom_keypair_promise
// Parameters: no parameters
// Returns: a Promise that resolve to an elliptic curve key using P-384 with cipher key derivation privileges. Allows for deriving AES 256 cipher key
//  -- 
function axiom_keypair_promise() {
    // Generate a local public/private key pair
    let p =  g_crypto.generateKey({
            'name': "ECDSA",
            'namedCurve': "P-384"
        },
        true,
        ["deriveKey"]
    )
    return p  // promise
}


//>--
// pc_wrapper_keypair_promise
// Parameters: no parameters
// Returns: a Promise that resolves to an RSA-OAEP key modulus 4096 hash to SHA-256 with wrapKey and unwrapKey privileges
//  -- 
function pc_wrapper_keypair_promise() {  // return
    // Generate a local public/private key pair
    let p =  g_crypto.generateKey({
            name: "RSA-OAEP",
            modulusLength: 4096, //can be 1024, 2048, or 4096
            publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
            hash: { name: "SHA-256" }, //can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
        },
        true,
        ["wrapKey","unwrapKey"]
    )
    return p  // promise
}
//--<


/*
// aes_encryptor
// Parameters:  
//        		encodable -  a string
//   			aes_key - aes_key as CryptoKey
//				nonce - random (gen_nonce) passed as a uint8Array
// Returns: The enciphered text ArrayBuffer
*/
async function aes_encryptor(encodable,aes_key,nonce) {

	let enc = new TextEncoder();
	let clear_buf =  enc.encode(encodable);
	let iv = nonce

    let ciphertext = await g_crypto.encrypt({
												name: "AES-CBC",
												iv
											},
											aes_key,
											clear_buf
										);
	return ciphertext
}


/*
// aes_decipher_message
// Parameters:  
//  			message -  as a uint8Array
//				aes_key - aes key as CryptoKey
//				nonce - random (gen_nonce) passed as a uint8Array
// Returns: clear text
*/
async function aes_decipher_message(message,aes_key,nonce) {
	let iv = nonce
    let decrypted = await g_crypto.decrypt({
												name: "AES-CBC",
												iv
											},
											aes_key,
											message
										);
	//
	let dec = new TextDecoder()
	let clear = dec.decode(decrypted)
	return clear
}
//
// 



/*
// galactic_user_starter_keys
// Parameters: no parameters or (optional) a selector parameter
// 
// Optional parameters values:  "wrapper", "signer"  
//								Purpose:  produce only the selected key pair
//    make a priv/pub key pair.
// Return: an object containing all key pairs
//
	let key_info = {
		"pk_str" : pub_key_str,
		"priv_key" : priv_key_str,
		"signer_pk_str"  : sign_pub_key_str,
		"signer_priv_key" : sign_priv_key_str
		"axiom_pk_str" : axiom_pub_key_str,
		"axiom_priv_key" : axiom_priv_key_str		
	}
//
*/
async function galactic_user_starter_keys(selector) {
	//
	let pub_key_str = false
	let priv_key_str = false
	if ( (selector === undefined) || (selector === "wrapper") ) {
		// Generate a local public/private key pair WRAPPER
		let keypair = await pc_wrapper_keypair_promise()
		// ---- ---- ---- ----
		let pub_key = keypair.publicKey
		let priv_key = keypair.privateKey
		// ---- ---- ---- ----                                      // g_nonce_buffer - space to use
		let exported = await g_crypto.exportKey("jwk",pub_key);
		pub_key_str = JSON.stringify(exported)

		let priv_exported = await g_crypto.exportKey("jwk",priv_key);
		priv_key_str =  JSON.stringify(priv_exported);
	}

	let sign_pub_key_str = false
	let sign_priv_key_str = false
	if ( (selector === undefined) || (selector === "signer") ) {
		// Generate a local public/private key pair SIGNER
		let signer_pair = await pc_keypair_promise()

		let signer_pub_key = signer_pair.publicKey
		let signer_priv_key = signer_pair.privateKey

		let sign_exported = await g_crypto.exportKey("jwk",signer_pub_key);
		sign_pub_key_str = JSON.stringify(sign_exported)

		let sign_priv_exported = await g_crypto.exportKey("jwk",signer_priv_key);
		sign_priv_key_str =  JSON.stringify(sign_priv_exported);
	}


	let axiom_pub_key_str = false
	let axiom_priv_key_str = false
	if ( (selector === undefined) || (selector === "derive") ) {
		// Generate a local public/private key pair SIGNER
		let axiom_pair = await axiom_keypair_promise()

		let axiom_pub_key = axiom_pair.publicKey
		let axiom_priv_key = axiom_pair.privateKey

		let axiom_exported = await g_crypto.exportKey("jwk",axiom_pub_key);
		axiom_pub_key_str = JSON.stringify(axiom_exported)

		let axiom_priv_exported = await g_crypto.exportKey("jwk",axiom_priv_key);
		axiom_priv_key_str =  JSON.stringify(axiom_priv_exported);
	}
	
	//
	let key_info = {
		"pk_str" : pub_key_str,
		"priv_key" : priv_key_str,
		"signer_pk_str"  : sign_pub_key_str,
		"signer_priv_key" : sign_priv_key_str,
		"axiom_pk_str" : axiom_pub_key_str,
		"axiom_priv_key" : axiom_priv_key_str
	}

	if ( key_info.pk_str === false ) {
		delete key_info.pk_str
		delete key_info.priv_key
	}
	if ( key_info.signer_pk_str === false ) {
		delete key_info.signer_pk_str
		delete key_info.signer_priv_key
	}
	if ( key_info.axiom_pk_str === false ) {
		delete key_info.axiom_pk_str
		delete key_info.axiom_priv_key
	}

	return(key_info)
}





/*
// protect_hash
// Parameters: 
//          -- priv_keys - structure containing private keys for signing {priv_keys.signer_priv_key}
//          -- aes_key - aes key as CryptoKey
//          -- nonce - base64url encoded uint8Array
//          -- string_to_be_signed
// wrap a hash of the biomarker -- done before server create identity operation 
// Returns: As the toString of a Uint8Array  (commad delimited entries, csv)
*/

async function protect_hash(priv_keys,aes_key,nonce,string_to_be_signed) {
	//
	try {
		let priv_signer_key = priv_keys.signer_priv_key
		let sig_txt = await key_signer(string_to_be_signed,priv_signer_key)
		let iv_nonce = from_base64_to_uint8array(nonce)
		let cipher_sig = await aes_encryptor(sig_txt,aes_key,iv_nonce)
		//
		let cipher_sig_buf = new Uint8Array(cipher_sig)
		return to_base64_from_uint8array(cipher_sig_buf)
	} catch (e) {
	  console.log(e)
	  return false
	}
	//
}


/*
// verify_protected
// Parameters: 
//          -- string_that_was_signed - (just the string as is)
//			-- encrypted_sig - the signature returned by protect_hash
//          -- aes_key - aes key as CryptoKey
//			-- pub_keys - An object containing public keys {pub_keys.signer_pk_str}
//          -- nonce - base64url encoded uint8Array
//          -- string_to_be_signed
// wrap a hash of the biomarker -- done before server create identity operation 
// Returns: As the toString of a Uint8Array  (commad delimited entries, csv)
*/

async function verify_protected(string_that_was_signed,encrypted_sig,pub_keys,aes_key,nonce) {
	try {
		let signer_pk_str = pub_keys.signer_pk_str
		let iv_nonce = from_base64_to_uint8array(nonce)
		let cipher_sig = await from_base64_to_uint8array(encrypted_sig)
		let clear_sig =  await g_crypto.decrypt({
													name: "AES-CBC",
													iv  : iv_nonce
												},
												aes_key,
												cipher_sig
											);
		const decoder = new TextDecoder();
		let sig_txt = decoder.decode(clear_sig);
		//
		let verified = await verifier(string_that_was_signed,sig_txt,signer_pk_str)
		return verified
	} catch (e) {
		console.log(e)
	}
	return false
}

/*
// gen_public_key
// Parameters:
//     		-- info - an info object (javascript object) which gain fields info.public_key and info.signer_public_key
//                      optionally provides a field info.biometric, which will be signed and signature will be put into this field
//       	-- store_info - a method taking two parameters (info,privates)  privates is the Object created in this method
*/
async function gen_public_key(info,store_info) {
	let keys = await galactic_user_starter_keys()
	//
	info.public_key = keys.pk_str		// user info is the basis for creating a user cid the public key is part of it
	info.signer_public_key = keys.signer_pk_str
	//
	let aes_key = await gen_cipher_key()
	let storable_key = await aes_to_str(aes_key) 
	let nonce = gen_nonce()
	//
	let privates = {		// private keys will be stored locally, and may offloadded from the browser at the user's discretion.
		'priv_key' : keys.priv_key,
		'signer_priv_key' : keys.signer_priv_key,
		'signature_protect' : {
			"key" : storable_key,
			"nonce" : nonce
		}
	}
	info.biometric = await protect_hash(privates,aes_key,nonce,info.biometric)
	if ( store_info ) store_info(info,privates)
}

/*
//>--
// unwrapped_aes_key
// Parameters: 
//            -- wrapped_aes : as a buffer containing a jwk formatted key
//            -- unwrapper_key : as a buffer the result of importing the key
// Returns: aes_key as a CryptoKey structure (see crypto.subtle.generateKey) with encrypte and decrypt permissions
*/
async function unwrapped_aes_key(wrapped_aes,unwrapper_key) {
  let unwrapped_aes = await g_crypto.unwrapKey(
        "jwk", // same as wrapped
        wrapped_aes, //the key you want to unwrap
        unwrapper_key, //the private key with "unwrapKey" usage flag
        {   //these are the wrapping key's algorithm options
            name: "RSA-OAEP",
            modulusLength: 4096, //can be 1024, 2048, or 4096
            publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
            hash: { name: "SHA-256" }, //can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
        },
        {   //this what you want the wrapped key to become (same as when wrapping)
            name: "AES-CBC",
            length: 256
        },
        true, //whether the key is extractable (i.e. can be used in exportKey)
        ["encrypt", "decrypt"] //the usages you want the unwrapped key to have
      )
  //
  return unwrapped_aes
}
//--<


/*
//>--
// derive_aes_key
// Parameters: 
//            -- sender_pub_key_buffer : as a buffer containing a jwk formatted key
//            -- local_private : as a buffer the result of importing the key
// Returns: aes_key as a CryptoKey structure (see crypto.subtle.generateKey) with encrypte and decrypt permissions
*/
async function derive_aes_key(remote_pub_key_buffer,local_private) {
	let derived_aes = await g_crypto.deriveKey(
	  {
		name: "ECDH",
		public: remote_pub_key_buffer
	  },
	  local_private,
	  {
		name: "AES-CBC",
		length: 256
	  },
	  false,
	  ["encrypt", "decrypt"]
	);

	return derived_aes
}


/*
// key_wrapper
// Parameters:
//        -- key_to_wrap  as Cryptokey
//        -- pub_wrapper_key :  the public wrapper key (for instance a receiver key) as jwk in JSON parseable string
// Returns: the wrapped key in a string that can be sent
*/
async function key_wrapper(key_to_wrap,pub_wrapper_key) {
	try {
		let wrapper_jwk = JSON.parse(pub_wrapper_key)
		let wrapper = await g_crypto.importKey(
				"jwk",
				wrapper_jwk,
				{   //these are the wrapping key's algorithm options
					name: "RSA-OAEP",
					modulusLength: 4096, //can be 1024, 2048, or 4096
					publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
					hash: { name: "SHA-256" }, //can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
				},
				true,
				["wrapKey"]
		);

		let wrapped_key = await g_crypto.wrapKey(
											"jwk",
											key_to_wrap,
											wrapper,
											{   //these are the wrapping key's algorithm options
												name: "RSA-OAEP"
											}
										);
		let type8 = new Uint8Array(wrapped_key)
		let tranportable = to_base64_from_uint8array(type8)
		return tranportable
	} catch(e) {
		console.log(e)
	}
	return false
}


/*
// key_unwrapper
// Parameters:
//        -- wrapped_key : as base64url encoded uint8array for passing to unwrapped_aes_key
//        -- piv_wrapper_key :  the private key (for instance a sender key) as a JSON.parseable string representing jwk
// Returns: the unwrapped key in a string that can be sent
*/
async function key_unwrapper(wrapped_key,piv_wrapper_key) {
	let wrapper_jwk = JSON.parse(piv_wrapper_key)
	let unwrapper = await g_crypto.importKey(
			"jwk",
			wrapper_jwk,
			{   //these are the wrapping key's algorithm options
				name: "RSA-OAEP",
				modulusLength: 4096, //can be 1024, 2048, or 4096
				publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
				hash: { name: "SHA-256" }, //can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
			},
			true,
			["unwrapKey"]
	);
	
	// wrapped_key
	let wrapped_aes = from_base64_to_uint8array(wrapped_key)
	let aes_key = await unwrapped_aes_key(wrapped_aes,unwrapper)
	return aes_key
}




/*
// derive_key
// Parameters:
//        -- sender_public_key : as base64url encoded uint8array representation of a ECDH public key with derivation privileges.
//        -- piv_axiom_key :  the private key (for instance a sender key) as a JSON.parseable string representing jwk
// Returns: the unwrapped key in a string that can be sent
*/
async function derive_key(sender_public_key,piv_axiom_key) {
	let axiom_jwk = JSON.parse(piv_axiom_key)
	let local_private = await g_crypto.importKey(
			"jwk",
			axiom_jwk,
			{   //these are the wrapping key's algorithm options
				name: "RSA-OAEP",
				modulusLength: 4096, //can be 1024, 2048, or 4096
				publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
				hash: { name: "SHA-256" }, //can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
			},
			true,
			["deriveKey"]
	);
	
	// wrapped_key
	let sender_pub_key_buffer = from_base64_to_uint8array(sender_public_key)
	let aes_key = await derive_aes_key(sender_pub_key_buffer,local_private)
	return aes_key
}




/*
// aes_to_str 
// Parameters: 
        -- aes_key - as Cryptokey
        -- transport_type :  can be "jwk" or "raw"
  Export an AES secret key given an ArrayBuffer containing the raw bytes.
// Returns: the export key JSON.stringify if 'jwk' ||  base64url Uint8Array if 'raw'
*/
async function aes_to_str(aes_key,transport_type) {
	switch ( transport_type ) {
		case "jwk" : {
			const exported = await g_crypto.exportKey("jwk", aes_key);
			let key_str = JSON.stringify(exported)
			return key_str
		}
		case "raw" :
		default: {
			const exported = await g_crypto.exportKey("raw", aes_key);
			const exportedKeyBuffer = new Uint8Array(exported);
			let key_str = to_base64_from_uint8array(exportedKeyBuffer)
			return key_str
		}
	}
}

/*
// importAESKey
// Parameters:
//        -- rawKey 
//        -- transport_type :  can be "jwk" or "raw"
// Returns:  a Promise   (await this function) resolves to a CryptoKey representing the secret key
  Import an AES secret key from an ArrayBuffer containing the raw bytes.
  Takes an ArrayBuffer string containing the bytes.
*/
function importAESKey(rawKey,transport_type) {
  return g_crypto.importKey(
		transport_type,
		rawKey,
		{
			name: "AES-CBC",
			length: 256
		},
		true,
		["encrypt", "decrypt"]
  );
}

/*
// aes_from_str
// Parameters:
//        -- aes_key_str  : 	the export key JSON.stringify if 'jwk' 
//        -- transport_type :  can be "jwk" or "raw" ||  base64url Uint8Array if 'raw'
// Returns:  the aes_key Cryptokey the result of import
*/
async function aes_from_str(aes_key_str,transport_type) {
	switch ( transport_type ) {
		case "jwk" : {
			try {
				let key_obj = JSON.parse(aes_key_str)
				let key = await importAESKey(key_obj,"jwk")
				return key
			} catch (e) {}
			break;
		}
		case "raw" :
		default: {
			let buf = from_base64_to_uint8array(aes_key_str)
			let key = await importAESKey(buf,"raw")
			return key
		}
	}
}


/*
// key_signer
// Parameters:
//        -- data_to_sign  as a string 
//        -- priv_signer_key :  the private key (for instance a sender key) for signing 
//                              passed as a string that can be JSON.parserd into a jwk format
// Returns: the a base64url string containing the signature
*/
async function key_signer(data_to_sign,priv_signer_key) {
	try {
		let signer_jwk = JSON.parse(priv_signer_key)
		let signer = await g_crypto.importKey(
				"jwk",
				signer_jwk,
				{
					'name': "ECDSA",
					'namedCurve': "P-384"
				},
				true,
				["sign"]
		);

		let enc = new TextEncoder();
		let signable = enc.encode(data_to_sign);
		let signature = await g_crypto.sign({
												name: "ECDSA",
												hash: {name: "SHA-384"},
											},
											signer,
											signable
										);

		let type8 = new Uint8Array(signature)
		let tranportable = to_base64_from_uint8array(type8)
		return tranportable
	} catch(e) {
		console.log(e)
	}
	return false
}


/*
// verifier
// Parameters:
//		-- was_signed_data : as a string that was originially passed to key_signer
//		-- signature : the a base64url string containing the signature
//		-- signer_pub_key :  the public key (for instance a sender key) for verification  
//                           passed as a string that can be JSON.parserd into a jwk format
// Returns: bool
*/
async function verifier(was_signed_data,signature,signer_pub_key) {
	try {
		let signer_jwk = JSON.parse(signer_pub_key)
		let verifier = await g_crypto.importKey(
				"jwk",
				signer_jwk,
				{
					'name': "ECDSA",
					'namedCurve': "P-384"
				},
				true,
				["verify"]
		);
		//
		let enc = new TextEncoder();
		let verifiable = enc.encode(was_signed_data);

		let sig_bytes = from_base64_to_uint8array(signature)

		let result = await g_crypto.verify({
											name: "ECDSA",
											hash: {name: "SHA-384"},
										},
										verifier,
										sig_bytes,
										verifiable
									);
		return result
	}  catch(e) {
		console.log(e)
	}
	return false
}


/*
// encipher_message
// Parameters:
//        -- message :  a text string
//        -- aes_key :  as CryptoKey
//        -- nonce : as a string storing a buffer base64url
// Returns: a base64url encoding of the enciphered buffer
*/
async function encipher_message(message,aes_key,nonce) {
	try {
		if ( aes_key ) {
			let iv_nonce = from_base64_to_uint8array(nonce)
			let enciphered = await aes_encryptor(message,aes_key,iv_nonce)
			let b8a = new Uint8Array(enciphered)
			return to_base64_from_uint8array(b8a)
		}
	} catch(e) {
		console.log(e)
	}
	return false
}
// 


/*
// decipher_message
// Parameters:
//        -- message :  as a string storing a buffer formatted as csv of the entries
//        -- wrapped_key :  wrapped aes key 
//                          passed as a string that can be JSON.parsed into a jwk format object
//        -- priv_key : the private key for unwrapping
//        -- nonce : as a string storing a buffer base64url
// Returns: The clear string or false if it cannot be decrypted
*/
async function decipher_message(message,wrapped_key,priv_key,nonce) {
	try {
		let aes_key = await key_unwrapper(wrapped_key,priv_key)
		if ( aes_key ) {
			let iv_nonce = from_base64_to_uint8array(nonce)
			let buffer = from_base64_to_uint8array(message)
			let clear = await aes_decipher_message(buffer,aes_key,iv_nonce)
			return clear
		}
	} catch(e) {
		console.log(e)
	}
	return false
}
// 


/*
// derived_decipher_message
// Parameters:
//        -- message :  base64url encoded string returned from encipher
//        -- remote_public : a pubic key for ECDH P-384 key encryption 
//                          passed as a string that can be JSON.parsed into a jwk format object
//        -- priv_key : the private key forming the local counterpart to the sender_public key.
//        -- nonce : as a string storing a buffer base64url
// Returns: The clear string or false if it cannot be decrypted
*/
async function derived_decipher_message(message,remote_public,priv_key,nonce) {
	try {
		let aes_key = await derive_key(remote_public,priv_key)
		if ( aes_key ) {
			let iv_nonce = from_base64_to_uint8array(nonce)
			let buffer = from_base64_to_uint8array(message)
			let clear = await aes_decipher_message(buffer,aes_key,iv_nonce)
			return clear
		}
	} catch(e) {
		console.log(e)
	}
	return false
}
//


// ----------------------------  allow certain methods to be global (up to the application to call)
function windowize_crypto_wraps() {
  //
	window.gen_nonce = gen_nonce
	window.aes_encryptor = aes_encryptor
	window.aes_decipher_message = aes_decipher_message
	window.pc_keypair_promise = pc_keypair_promise
	window.pc_wrapper_keypair_promise = pc_wrapper_keypair_promise
	window.axiom_keypair_promise = axiom_keypair_promise
	//
	window.galactic_user_starter_keys = galactic_user_starter_keys
	//
	window.gen_cipher_key = gen_cipher_key
	window.protect_hash = protect_hash
	window.verify_protected = verify_protected
	window.gen_public_key = gen_public_key
	window.unwrapped_aes_key = unwrapped_aes_key
	window.derive_key = derive_key
	window.aes_to_str = aes_to_str
	window.aes_from_str = aes_from_str
	window.key_wrapper = key_wrapper
	window.key_unwrapper = key_unwrapper
	window.key_signer = key_signer
	window.verifier = verifier
	window.encipher_message = encipher_message
	window.decipher_message = decipher_message
	window.derived_decipher_message = derived_decipher_message
  //
}



//
// MODULE: CRYPTO WRAPS (windowized)

const HASH_SEP = '!'

// >> import
//modularize>> import * as base64 from "../modules/base64.js";
//modularize>> import * as base64 from "../modules/base_string.js";
//<<


//$>>	fetch_tables
let formats = false;
let multibase = false;

async function fetch_tables() {

    formats = await fetch('../assets/formats.json')
    .then(response => response.json());

    multibase = await fetch('../assets/multibase.json')
        .then(response => response.json());

    return true
}

setTimeout(fetch_tables,0)


//$>>	do_hash_buffer
async function do_hash_buffer(text) {
    const encoder = new TextEncoder();
    const data = encoder.encode(text);
    const hash = await g_crypto.digest('SHA-256', data);
    return hash
}

//$>>	do_hash
async function do_hash(text) {
    let buffer = await do_hash_buffer(text)
    const hashArray = Array.from(new Uint8Array(buffer));
    return base64.bytesToBase64(hashArray)
}

//$>>	to_base64
function to_base64(text) {
    return base64.base64encode(text)
}

//$>>	from_base64
function from_base64(base64text) {
    let bytesAsText = base64.base64decode(base64text)
    return bytesAsText
}


// https://docs.ipfs.io/concepts/content-addressing/
// -- https://github.com/multiformats/multicodec/blob/master/table.csv
// MULTI BASE FOR IPFS Support 
// u = no padding
// U = with padding
/*

function do_hash (text) {
    const hash = crypto.createHash('sha256');
    hash.update(text);
    let ehash = hash.digest('base64');
    ehash = ehash.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    return(ehash)
}


sha2-256	multihash	0x12	permanent	
sha2-512	multihash	0x13	permanent	
sha3-512	multihash	0x14	permanent	
sha3-384	multihash	0x15	permanent	
sha3-256	multihash	0x16	permanent	
sha3-224	multihash	0x17	permanent	

// does not start with Qm, so it is v1.

let cidV1 = 'u' +  encode( 0x55 | 0x12 |  256  encoded 256 bytes...) 


base64url - cidv1 - raw - (sha2-256 : 256 : 6E6FF7950A36187A801613426E858DCE686CD7D7E3C0FC42EE0330072D245C95)

multibase - version - multicodec - multihash (name : size : digest in hex)

*/


//$>>	CWID

const _do_hash = do_hash

class CWID {

    constructor() {
        this.version = '01'
        this.size = 256/8
        this.hash_code = formats ? formats["sha2-256"].code.substr(2) : '12'
        this.base = 'base64url'
        this.base_code = multibase ? multibase['base64url'].code : 'u'
        this.data_type = 'raw'
        this.type_code = formats ? formats[this.data_type].code.substr(2) : '55'
        this._descriptor = false
        this.tables_promised = false
        this.select_base(this.base)
    }

    correct_base(base) {
        if ( base === 'hex') return 'base16'
        else if ( base === 'oct' ) return 'base8'
        return base
    }

    async select_base(base) {
        if ( this.tables_promised !== false ) {
            await this.tables_promised
            this.tables_promised = false
        }
        if ( multibase === false ) {
            this.tables_promised = new Promise((resolve,reject) => {
                setTimeout(async () => {
                    let b = await fetch_tables()
                    resolve(b)
                },0)    
            })
        } else {
            base = this.correct_base(base)
            this.base = base
            this.base_code = multibase[base].code
            this._descriptor = false
            this.descriptor()    
        }
    }

    _descriptor_in_base() {
        if ( this.base !== 'base16' ) {
            switch ( this.base ) {
                case 'base64url': {
                    let AoB = base_string.hex_toByteArray(this._descriptor)
                    let descr = base64.bytesToBase64(AoB)
                    this._descriptor = descr.replace(/\=+/g,'')
                    break;
                }
                case 'base64' :
                default: {
                    let AoB = base_string.hex_toByteArray(this._descriptor)
                    this._descriptor = base64.bytesToBase64(AoB,true)
                    break;
                }
            }
        }
        return this._descriptor
    }

    async _hash_of_sha(text,base) {
        if ( !(base) ) base = 'base64url'
        if ( base === 'base64url' ) {
            let hh = await _do_hash(text)
            return hh.replace(/\=+/g,'')
        } else if ( base === 'hex' || base === 'base16' ) {
            let b64 = await do_hash_buffer(text)
            return base_string.hex_fromTypedArray(new Uint8Array(b64))
        } else {
            return  await _do_hash(text)
        }
    }

    descriptor() {
        if ( this._descriptor ) {
            return this._descriptor
        }
        let dstr = this.version.toString(16)
        dstr += this.type_code
        dstr += this.hash_code
        dstr += this.size.toString(16)
        this._descriptor = dstr
        dstr = this._descriptor_in_base()
        return dstr
    }

    async cwid(text) {
        let hh = await this._hash_of_sha(text,this.base)
        let code = this.descriptor()
        let _cwid = this.base_code + code + HASH_SEP + hh
        return _cwid
    }

    hash_from_cwid(cwid) {
        let parts = cwid.split(HASH_SEP)
        return(parts[1])
    }

    hash_buffer_from_cwid(cwid) {
        let base = cwid[0]
        let hh = this.hash_from_cwid(cwid)
        let ua8 = false
        if ( base === 'u' ) {
            while ( hh.length % 4 ) hh += '='
            ua8 = base64.base64ToBytes(hh)
        } else if ( base === 'f' ) {
            ua8 = base_string.hex_toByteArray(hh)
        }
        return ua8
    }


    _hex_parts_to_CWID(prefix,rest) {
        let preBuf = base_string.hex_toByteArray(prefix)
        let tailBuf = base_string.hex_toByteArray(rest)
        prefix = base64.bytesToBase64(preBuf)
        prefix = prefix.replace(/\=+/g,'')
        rest = base64.bytesToBase64(tailBuf)
        rest = rest.replace(/\=+/g,'')
        let cwid = 'u' + prefix + HASH_SEP + rest
        return cwid
    }

    _base64_parts_to_hex_CWID(prefix,rest) {
        while ( prefix.length % 4 ) prefix += '='
        while ( rest.length % 4 ) rest += '='
        let preBuf = base64.base64ToBytes(prefix)
        let tailBuf = base64.base64ToBytes(rest)
        prefix = base_string.hex_fromByteArray(preBuf)
        rest = base_string.hex_fromByteArray(tailBuf)
        let cwid = 'f' + prefix + HASH_SEP + rest
        return cwid
    }


    change_base(cwid,to) {
        let from = cwid[0]
        let code = cwid.substr(1)
        if ( from === to ) {
            return cwid
        }
        switch(from) {
            case 'f' : {
                if ( to === 'u' ) to = 'base64url'
                if ( (to !== 'base64') && (to !== 'base64url') ) {
                    console.log("only support from hex-to-base64<type>")
                    return false
                }
                let [prefix,rest] = code.split(HASH_SEP)
                return this._hex_parts_to_CWID(prefix,rest)
            }
            case 'u': {
                if ( from === 'u' ) from = 'base64url'
                if ( to === 'f' ) to = 'hex'
                if ( (to !== 'base16') && (to !== 'hex') ) {
                    console.log("only support from hex-to-base64<type>")
                    return false
                }
                let [prefix,rest] = code.split(HASH_SEP)
                return this._base64_parts_to_hex_CWID(prefix,rest)
            }
        }
        return false
    }

    async ipfs_cid(text) {
        if ( this.base === 'base16' ) {
            let _cwid = await this.cwid(text)
            _cwid = _cwid.replace(HASH_SEP,'')
            return _cwid
        } else if ( (this.base === 'base64') || (this.base === 'base64url') ) {
            let _cwid = await this.cwid(text)
            this.select_base('base64url')
            return this.cwid_to_cid(_cwid)
        } else {
            let backup_base = this.base
            this.select_base('base16')
            let _cwid = await this.cwid(text)
            _cwid = _cwid.replace(HASH_SEP,'')
            this.select_base(backup_base)
            return _cwid
        }
    }

    ipfs_cid_to_cwid(cid) {
        let code = cid[0]
        let bytes = cid.substr(1)
        let cwid = ''
        switch (code) {
            case 'f' : {
                let prefix = bytes.substr(0,8)
                let rest  = bytes.substr(8)
                cwid = 'f' + prefix + '!' + rest
                break
            }
            case 'u' : {
                let buf = base64.base64ToBytes(bytes)
                let hexstr = base_string.hex_fromByteArray(buf)
                let prefix = hexstr.substr(0,8)
                let rest  = hexstr.substr(8)
                cwid = this._hex_parts_to_CWID(prefix,rest)
                break
            }
            default : {
                return false
            }
        }
        return cwid
    }

    cwid_to_cid(cwid) {
        let parts = cwid.split(HASH_SEP)
        let p = parts[0].substr(1)
        while ( p.length % 4 ) p += '='
        parts[0] = base64.base64ToBytes(p)
        p = parts[1]
        while ( p.length % 4 ) p += '='
        parts[1] = base64.base64ToBytes(p)
        var bytes = new Uint8Array([
            ...parts[0],
            ...parts[1]
        ]);
        let cid = base64.bytesToBase64(bytes)
        cid = this.base_code + cid
        return cid
    }

}



//$EXPORTABLE::
/*
fetch_tables
do_hash_buffer
do_hash
to_base64
from_base64
CWID
*/









class UCWID {
    //
    constructor(conf) {
        //
        this.cwid_service = new CWID()
        //
        this.key_pack = false
        this.normalizer_wait = false
        this.normalizer_promise = false
        if ( (conf === undefined) || (conf.normalizer === undefined) ) {
            this.normalizer_wait = true
            let p = new Promise((resolve,reject) => {
                (async () => {
                    const moduleSpecifier = './normalizers/unity.js';
                    const module = await import(moduleSpecifier)
                    const Normal = module.Unity
                    this.normalizer = new Normal(conf)
                    this.normalizer_wait = false
                    resolve(true)
                })();
            })
            this.normalizer_promise = p 
        } else {
            if ( typeof conf.normalizer === 'string' ) {
                this.normalizer_wait = true
                let p = new Promise((resolve,reject) => {
                    (async () => {
                        const moduleSpecifier = conf.normalize;
                        const module = await import(moduleSpecifier)
                        const Normal = module[conf.class_name]
                        this.normalizer = new Normal(conf)
                        this.normalizer_wait = false
                        resolve(true)
                    })();
                })
                this.normalizer_promise = p 
            } else if ( typeof this.normalizer === "function" ) {
                this.normalizer = conf.normalizer(conf)
            }
        }
        if ( (conf === undefined) || (conf._wrapper_key === undefined) ) {
            this.key_wait = true
            this.key_promise = new Promise((resolve,reject) => {
                (async () => { await this.provide_keys(); this.key_wait = false; resolve(true) })()
            })
        } else {
            this.key_wait = false
            this._wrapper_key = conf._wrapper_key
        }
    }

    wait_for_normalizer() {
        return [this.normalizer_wait, this.normalizer_promise]
    }

    wait_for_key() {
        return [this.key_wait, this.key_promise]
    }

    key_package() {
        return this.key_pack
    }

    //
    async provide_keys() {
        let key_pack = await cwraps.galactic_user_starter_keys("wrapper")
        this._wrapper_key = key_pack.pk_str
        this.key_pack = key_pack
        return key_pack
    }

    set wrapper_key(wkey) {
        this._wrapper_key = wkey
    }

    get wrapper_key() {
        return this._wrapper_key
    }

    async ucwid_constructor(clear_cwid,crypto_cwid) {
        let ucwid_packet = {
            "clear_cwid" : clear_cwid,
            "crypto_cwid" : crypto_cwid
        }
        let n_version = this.normalizer.version()
        let pack_str = JSON.stringify(ucwid_packet)
        let packet_cwid = await this.cwid_service.cwid(pack_str)
        let u_cwid = n_version + '!' + packet_cwid
        return [u_cwid,ucwid_packet]     
    }

    //
    async ucwid(data) {
        //
        let normalize = false
        let buf_as_str = false 

        if ( typeof data === "string" ) {
            normalize = true
            buf_as_str = atob(data)
            data = this.normalizer.normalize(data)
        } else { //make them the same until there is a method for digital normalization...
            buf_as_str = to_base64_from_uint8array(data)
            data = buf_as_str
        }

        // clear ID
        let clear_cwid = await this.cwid_service.cwid(data)
        let c_cwid_hash = clear_cwid.split('!')[1]
console.log(c_cwid_hash)
        // crypto ID
        let nonce = cwraps.gen_nonce(c_cwid_hash)
console.log(nonce)
        let aes_key = await cwraps.gen_cipher_key()
        let cipher_text = await cwraps.encipher_message(buf_as_str,aes_key,nonce)
        let crypto_cwid = await this.cwid_service.cwid(cipher_text)
        //
        // UCWID formation
        let wrapped_key = await cwraps.key_wrapper(aes_key,this._wrapper_key)
        //
        let [u_cwid,ucwid_packet] = await this.ucwid_constructor(clear_cwid,crypto_cwid)
        //
        return { "ucwid" : u_cwid, "info" : {
                                                "ucwid_packet" : ucwid_packet,
                                                "wrapped_key" : wrapped_key,
                                                "nonce" : nonce,
                                                "cipher_text" : cipher_text,
                                                "type_original" : normalize ? "string" : "buffer"
                                            }}
    }
}




// MODULE: ONE TABLE(windowized)

// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

//>>  AppDBWrapper


// In the following line, you should include the prefixes of implementations you want to test.
window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
// DON'T use "var indexedDB = ..." if you're not in a function.
// Moreover, you may need references to some window.IDB* objects:
window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction || {READ_WRITE: "readwrite"}; // This line should only be needed if it is needed to support the object's constants for older browsers
window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;
// (Mozilla has never prefixed these objects, so we don't need window.mozIDB*)


/*

// autoIncrement set to true  (for this special case DB use )

DB_VERSION
DATA_STORE
describe_data

*/


function warn(str) {
    //
}


// a session is a project...
// a session object (sessionObject) is stored in the DB and may contain parts of data
// part_id identifies a part of the data (e.g. a layer or a component)

class AppDBWrapper {

    constructor(name,conf) {
        this._can_process_db = true
        if ( !(window.indexedDB) ) {
            this._can_process_db = false
            console.log("Your browser doesn't support a stable version of IndexedDB. Such and such feature will not be available.");
        }
        //
        let self = this
        // DATA_STORE
        // DB_VERSION
        // describe_data
        if ( conf ) {
            for ( let ky in conf ) {
                self[ky] = conf[ky]
            }    
        }
        //
        this.db = false
        this.current_session_name = 'none'
        this._session_name_list = []
        this.name = name
        //
    }


    set session_name(name) {
        this.current_session_name = name
    }

    get session_name() {
        return this.current_session_name
    }

    get name_list() {
        return this._session_name_list
    }

    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    init_database() {
        //
        if ( !(this._can_process_db) ) return false
        let self = this
        let db_name = this.name
        //
        let p = new Promise((resolve,reject) => {

            let request = window.indexedDB.open(db_name, this.DB_VERSION);
            //
            // <-- onerror
            request.onerror = (event) => {
                alert(`This web app will not store ${this.describe_data} without the use of computer storage.`)
            };
            
            // <-- onsuccess
            request.onsuccess = (event) => {
                //
                let db = event.target.result;
                db.onerror = (event) => {
                    console.log("Database error: " + event.target.error);
                    reject(event.target.error)
                };
                //
                self.db = db;
                resolve(db)
            }

            // <-- onupgradeneeded
            request.onupgradeneeded = (event) => {
                //
                let db = event.target.result;
                //
                try {
                    let sessionObjectStore = db.createObjectStore(this.DATA_STORE, { autoIncrement : true });
                    sessionObjectStore.createIndex("name", "name", { unique: true });
                    sessionObjectStore.createIndex("sess_date_time", "sess_date_time", { unique: true });
                } catch (e) {
                }
            //
            };
        })  // end of promise
        //
        return p
    }


    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    //      load_name_list
    // -- 
    load_name_list() {
        if ( !(this.db) ) return
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readonly");
        let dataStore = transaction ? transaction.objectStore(this.DATA_STORE) : false
        //
        if ( !(dataStore) ) return false
        let p = new Promise((resolve,reject) => {
            this._session_name_list = []
            let myIndex = dataStore.index('name');
            myIndex.openCursor().onsuccess = (event) => {
                let cursor = event.target.result;
                if ( cursor ) {
                    this._session_name_list.push(cursor.value.name)
                    this.application_total_entry(cursor.value)
                    cursor.continue();
                } else {
                    this.application_update_session_name_selections(this.current_session_name,this._session_name_list)
                    resolve(true)
                }
            }
        })
        //
        return p
    }

    // _apply_find_by_name
    //  -- a generic that calls success_callback when an element matches the index, or not_found_callback otherwise.
    //
    _apply_find_by_name(sess_name, store, success_callback, not_found_callback) {
        let nameIndex = store.index('name');
        nameIndex.get(sess_name).onsuccess = (evt) => {
            let value = evt.target.result;
            if ( value ) {
                if ( success_callback ) success_callback(value,nameIndex);
            } else {
                if ( not_found_callback ) not_found_callback();
            }
        };
    }

    // _add_session_to_db
    //  -- adds the session object to the db, sets up the basic fields... 
    //
    _add_session_to_db(dataStore,application_op,part_id) {
        //
        let sessionObj = {
            'name' : this.current_session_name,
            'sess_date_time' : '' + Date.now(),
            'data' : { },
            'hashes' : { },
            'edit_order' : []
        }
        //
        if ( part_id ) sessionObj.edit_order.push(part_id)
        //
        if ( (application_op !== undefined) && (typeof application_op === 'function') ) {
            application_op(sessionObj)
        }
        let request = dataStore.add(sessionObj);
        return request
    }
  

    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    // add_data -- 
    //  Parameters: blob_data -- data stored as part of the session
    //              session id could be a layer....
    add_data(blob_data,part_id) {
        if ( !(this._can_process_db) ) return false
        if ( !(this.db) ) {
          console.log(`db not initialized :: AppDBWrapper.add_data`)
          return;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false

        let p = new Promise((resolve,reject) => {
            let self = this
            // update_list_callback
            let update_list_callback = (value,dbIndex) => {     // if found update
                if ( !dbIndex || (typeof value === "undefined") ) {
                    resolve(false)
                    return;
                }
                let keyRangeValue = IDBKeyRange.only(value.name);
                dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                    let cursor = event.target.result;
                    if ( cursor ) {
                        // existing session 
                        let sessionObj = cursor.value
                        //
                        let blob_url = (typeof blob_data === 'string') ? blob_data : URL.createObjectURL(blob_data);
                        // map_id = part_id
                        // store revised data
                        sessionObj.data[part_id] = blob_data
                        // make sure the structure has been set up if not already
                        if ( sessionObj.hashes[part_id] === undefined ) {
                            sessionObj.hashes[part_id] = {}
                        }
                        if ( sessionObj.hashes[part_id].op_history === undefined ) {
                            sessionObj.hashes[part_id].op_history = []
                        }
                        // record the order in which sessions (layers) have been edited
                        sessionObj.edit_order.push(part_id)
                        //
                        // update IndexedDB
                        const request = cursor.update(sessionObj);
                        request.onsuccess = async () => {
                            try {
                                self.application_data_update(blob_url,part_id,blob_data)  // application handling of data e.g visual rep
                            } catch (e) {
                                console.log(e)
                            } finally {
                                resolve(true)
                            }
                        };

                        request.onerror = (event) => {
                            resolve(false)
                        }
                        //
                    } else {
                        resolve(false)
                    }
                }
            }
            // add_new_callback
            let add_new_callback = () => {          // if not found add a new one
                //
                let blob_url = (typeof blob_data === 'string') ? blob_data : URL.createObjectURL(blob_data);
                //
                let application_op = (sessionObj) => {
                    //
                    sessionObj.data[part_id] = blob_data
                    if ( sessionObj.hashes[part_id] === undefined ) {
                        sessionObj.hashes[part_id] = {}
                    }
                    sessionObj.hashes[part_id].op_history = []
                    //
                } 
                //
                let request = self._add_session_to_db(dataStore,application_op,part_id)
                if ( request ) {
                    request.onsuccess = (event) => {
                        self.application_data_update(blob_url,part_id,blob_data)  // application handling of data e.g visual rep
                        resolve(true)
                    };
                    request.onerror = (event) => {
                        resolve(false)
                    }
                }
                //
            }
            //
            this._apply_find_by_name(this.current_session_name, dataStore, update_list_callback, add_new_callback)    
        })
        //
        return p
    }


    //  remove_data: 
    //      Parameters: part_id -- remove a sections of the data kept by the session named sess_name
    //                  sess_name -- A session or separate project or publication...
    //
    remove_data(part_id,sess_name) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: remove_audio_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //

        let p = new Promise((resolve,reject) => {
            // remove_from_list_callback
            let remove_from_list_callback = async (value,dbIndex) => {
                let keyRangeValue = IDBKeyRange.only(value.name);
                dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                    let cursor = event.target.result;
                    if ( cursor ) {
                        let sessionObj = cursor.value
                        delete sessionObj.data[part_id]
                        //
                        const request = cursor.update(sessionObj);
                        request.onsuccess = async () => {
                            //  item has been removed
                            console.log(`deleted ${part_id}`)
                            await this.app_secure_total_session(sess_name)
                            resolve(true)
                        };
                        //
                        request.onerror = (e) => {
                            resolve(false)
                        }
                    }
                    resolve(false)
                }
            }

            // not_found_callback 
            let not_found_callback = () => {
                warn(`The session ${sess_name} is not in the database`)
                resolve(false)
            }

            this._apply_find_by_name(sess_name, dataStore, remove_from_list_callback, not_found_callback)
        })

        return p
    }
      
    //  remove_data: 
    //      Parameters: part_id -- remove a sections of the data kept by the session named sess_name
    //                  sess_name -- A session or separate project or publication...
    //
    get_data(part_id,sess_name) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: remove_audio_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //

        let p = new Promise((resolve,reject) => {
            // remove_from_list_callback
            let get_from_list_callback = async (value,dbIndex) => {
                let keyRangeValue = IDBKeyRange.only(value.name);
                dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                    let cursor = event.target.result;
                    if ( cursor ) {
                        let sessionObj = cursor.value
                        let value =  sessionObj.data[part_id]
                        if ( value === undefined ) {
                            resolve(false)
                        } else {
                            resolve(value)
                        }
                    }
                    resolve(false)
                }
            }
        
            // not_found_callback 
            let not_found_callback = () => {
                warn(`The session ${sess_name} is not in the database`)
                resolve(false)
            }
        
            this._apply_find_by_name(sess_name, dataStore, get_from_list_callback, not_found_callback)
        })

        return p
    }
      
 
    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    //  get_session: 
    //      Parameters: sess_name -- A session or separate project or publication...
    //  Returns the object controlling all the data within the session.
    get_session(sess_name) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: get_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //
        let p = new Promise((resolve,reject) => {
          //
          // get_elem_callback
          let get_elem_callback = (value,dbIndex) => {          // element.name == sess_name exists
            //
            let keyRangeValue = IDBKeyRange.only(value.name);
            //
            dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
              let cursor = event.target.result;
              if ( cursor ) {
                let sessionObj = cursor.value
                resolve(sessionObj)
              } else {
                reject(null)
              }
            }
          }
          //
          // not_found_callback
          let not_found_callback = () => {                       // element.name == sess_name  NOT FOUND
            reject(null)
          }
          //
          this._apply_find_by_name(sess_name, dataStore, get_elem_callback, not_found_callback)
        })
        //
        return p
    }

     
    //  delete_session: 
    //      Parameters: sess_name -- A session or separate project or publication...
    //
    delete_session(sess_name) {
        //
        if ( !(this._can_process_db) ) return false

        if ( sess_name !== 'none ') {
            if ( this.db === null ) {
                console.log("db not initialized :: delete_session")
                return false;
            }
            //
            let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
            if ( !(transaction) ) return false
            let dataStore = transaction.objectStore(this.DATA_STORE);
            if ( !(dataStore) ) return false
        
            let p = new Promise((resolve,reject) => {
                // delete_from_list_callback
                let delete_from_list_callback = (value,dbIndex) => {
                    //
                    let keyRangeValue = IDBKeyRange.only(value.name);
                    //
                    dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                        let cursor = event.target.result;
                        if ( cursor ) {
                            let request = cursor.delete();
                            request.onsuccess = () => {
                                this.current_session_name = 'none'   /// here last
                                this.load_name_list()
                                this.application_revise_current_session(this.current_session_name)
                                resolve(true)
                            };
                        }
                        resolve(false)
                    }
                }
                //
                let not_found_callback = () => {
                    warn(`The session ${sess_name} is not in the database`)
                    resolve(false)
                }
                //
                this._apply_find_by_name(sess_name, dataStore, delete_from_list_callback, not_found_callback)    
            })
            //
            return p
        }
        return false
    }


    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    application_data_update(blob_url,part_id,blob_data) {
        // implemented by derived method (override)
    }

    async app_secure_total_session(sess_name) {
         // implemented by derived method (override)
    }

    application_revise_current_session(sess_name) {
        // implemented by derived method (override)
    }

    application_update_session_name_selections(sess_name,name_list) {

    }

    application_total_entry(sess_obj) {
        
    }

}




//$EXPORTABLE::
/*
AppDBWrapper
*/



// MODULE: FILE OPS (windowized)

//$>>	get_file_from_file_element
// called in response to a file selection through the system file browser
//
function get_file_from_file_element(file_el) {
	let p = new Promise((resolve,reject) => {
		let file_el = document.getElementById(file_el)
		file_el.addEventListener('change',(ev) => {
			//
			let file = file_el.files[0]
			let mtype = file.type
			if ( ext_of_file(file.name) === 'json' ) {
				let reader = new FileReader();
				if ( mtype === 'application/json' ) {
					reader.onload = (e) => {
						resolve(e.target.result)
					};
					reader.readAsText(file);
				}
			}
			//
		})
		file_el.click()
	})
	//
	return p
}


//$>>	generic_downloader
function generic_downloader(dataStr) {
	let downloadlink = document.getElementById("identity-download-link")
	if ( !(downloadlink) ) return false
	try {
		let mime_type = dataStr.substring(dataStr.indexOf(":")+1, dataStr.indexOf(";"))
		//
		let ext = mime_type.split('/')[1]
		//
		downloadlink.setAttribute("href",     dataStr     );
		downloadlink.setAttribute("download", (`untitled.${ext}`) );
		downloadlink.click();
	} catch (e) {}
}



//$EXPORTABLE::
/*
get_file
generic_downloader
*/

//  === ---------------------------------------  === ---------------------------------------  === --------------------------------------- 



// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
// MODULE: USER DB   (windowized)
//


/*
// user_data
{
    "name_key" : name_key,
    "name": '',
    "DOB" : "",
    "place_of_origin" : "", 
    "cool_public_info" : "", 
    "business" : false, 
    "public_key" : false,
    "signer_public_key" : false,
    "biometric" : false
}
*/


function identity_fn(data) {
    return data
}

let g_contacts = {}
function set_contact_map(contacts_map) {
    g_contacts = contacts_map
}

function contact_from_ucwid(user_ucwid) {
    let c = g_contacts[user_ucwid]
    return c
}

function name_key_of(user_info) {
    if ( (user_info.name === undefined) || (user_info.DOB === undefined) ) {
        return false
    }
    let name_key = `${user_info.name}-${user_info.DOB}`
    return name_key
}

function value_fallback(value) {
    let vv = value ? value : ""
    return vv
}


class HumanUserDB extends AppDBWrapper {

    constructor(conf) {
        super("human-user-records",conf)
        this.current_user_name = ""
        this.current_description = ""
        this.current_file_list = []
        //
        this.current_user_object = false
        this.current_user_data = false
        //
        this.clear_identity_list_data()
    }

    async add_user(user_object) {
        this.current_session_name = user_object.name
        let part_id = "user-meta"
        //
        let blob_data = user_object
        //
        blob_data = JSON.stringify(blob_data)
        await this.add_data(blob_data,part_id)
    }

    async update_user(user_object) {
        await this.add_user(user_object)
    }

    async get_user(sel_user) {
        try {
            let user_Obj = await this.get_session(sel_user)
            if ( user_Obj ) {
                //
                this.current_user_object = user_Obj
                //
                this.current_user_name = user_Obj.name
                //
                this.current_session_name = user_Obj.name
                //
                this.current_user_info = user_Obj.user_info
                //
                this.current_user_data = user_Obj.data
                //
                this.current_file_list = []
                let data_map = user_Obj.data
                for ( let part_id in data_map ) {
                    if ( part_id !== "user-meta" ) {
                        this.current_file_list.push(JSON.parse(data_map[part_id]))
                    }
                }
                //
                return user_Obj
            }
        } catch (e) {
            console.log("get_user")
        }
    }

    get_file_details(part_id) {
        if ( !(part_id) || (part_id.length === 0) ) return ""
        if ( this.current_user_object ) {
            let user_Obj = this.current_user_object
            if ( user_Obj ) {
                let data_map = user_Obj.data
                if ( typeof data_map[part_id] === "string" ) {
                    return JSON.parse(data_map[part_id])    
                }
            }
        }
        return false
    }

    //
    async add_file(file_name,description,svg,to_layer) {
        if ( svg === undefined ) svg = ""
        if ( to_layer == undefined ) to_layer = 0
        let file_record = {
            "name" : file_name, 
            "description" : description,
            "data" : "", "ouput" : "", "svg" : svg, "layer" : to_layer }
        //
        let data = JSON.stringify(file_record)
        await this.add_data(data,file_name)
    }

    //
    async remove_file(file_name) {
        this.current_session_name = this.current_user_name
        await this.remove_data(file_name,this.current_user_name)
    }

    //
    async remove_user() {
        this.current_session_name = this.current_user_name
        await this.delete_session(this.current_user_name)
    }

    // 
    async get_file_names() {
        let sess_name = this.current_session_name
        try {
            let sess_data = await this.get_session(sess_name)
            if ( sess_data ) {
                let f_names = Object.keys(sess_data.data)
                return f_names
            }    
        } catch (e) {
            console.log("get_file_names")
        }
        return []
    }

    async get_file_entries() {
        let sess_name = this.current_session_name
        try {
            let sess_data = await this.get_session(sess_name)
            if ( sess_data ) {
                let f_names = sess_data.data.map((f_data) => JSON.parse(f_data))
                return f_names
            }
        } catch (e) {
            console.log("get_file_entries")
        }
        return []    
    }

    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    app_add_fields(sessionObj) {
        sessionObj.project_name = this.current_user_name
        sessionObj.author = this.current_author
        sessionObj.description = this.current_description
    }

    application_data_update(blob_url,part_id,blob_data) {
        // implemented by derived method (override)
    }

    async app_secure_total_session(sess_name) {
         // implemented by derived method (override)
    }

    application_revise_current_session(sess_name) {
        // implemented by derived method (override)
    }

    application_update_session_name_selections(sess_name,name_list) {

    }


    clear_identity_list_data() {
        this.identity_list = []
        this.user_list = []
    }

    application_total_entry(identity) {
        this.identity_list.push(identity)
        this.user_list.push(identity.user_info)
    }


    async get_known_users() {
        this.clear_identity_list_data()
        await g_human_user_storage.load_name_list()
        return [this.user_list,this.identity_list]
    }
    

}



//$>>	db_startup

const DB_VERSION = 1
const DATA_STORE = "human-projects"
const describe_data = "user records"

let g_human_user_storage = false
let g_human_user_storage_ref = [false]

async function db_startup() {
    //
    g_human_user_storage = new HumanUserDB({
        "DB_VERSION" : DB_VERSION,
        "DATA_STORE" : DATA_STORE,
        "describe_data" : describe_data
    })

    await g_human_user_storage.init_database()
    await g_human_user_storage.load_name_list()

    g_human_user_storage_ref[0] = g_human_user_storage
    
    return g_human_user_storage
}



//$>>	store_user
async function store_user(user_information,privates) {
    if ( !g_human_user_storage ) return(false)
    //
    let name_key = name_key_of(user_information)
    if ( !name_key ) return(false)
    //
    let store_u_i = Object.assign({},user_information)
    //
    let storage_obj = {		// prepare a data structure to store data made by this app's ipfs gateway
        "name" : name_key,
        "user_info" : store_u_i,
        "data" : {},
        "ucwid" : '',
        "dirs" :  '',
        "files" :  '',
        "stored_externally" : false
    }
    //
    if ( privates.priv_key ) {
        storage_obj.priv_key = privates.priv_key
    }
    //
    if ( privates.signer_priv_key ) {
        storage_obj.signer_priv_key = privates.signer_priv_key
    }
    //
    if ( privates.signature_protect ) {
        storage_obj.signature_protect = privates.signature_protect
    }
    //
    await g_human_user_storage.add_user(storage_obj)
    return(true)
}



//$>>	get_known_users
async function get_known_users() {
    if ( g_human_user_storage ) {
        return await g_human_user_storage.get_known_users()
    }
    return false
}

//$>>	get_user_public_wrapper_key
async function get_user_public_wrapper_key(name_key) {
    let user_object = await g_human_user_storage.get_user(name_key)
    if ( user_object ) {
        let pub_key = g_human_user_storage.current_user_info.public_key
        return pub_key
    }
    return false
}



//$>>	get_user_public_signer_key
async function get_user_public_signer_key(name_key) {
	//
    let user_object = await g_human_user_storage.get_user(name_key)
    if ( user_object ) {
        let signer_public_key = g_human_user_storage.current_user_info.signer_public_key
        return signer_public_key
    }
    return false
}



//$>>	unstore_user
async function unstore_user(identity) {
    let name_key = identity.name
    if ( g_human_user_storage.current_user_name !== name_key ) {
        await g_human_user_storage.get_user(name_key)
    }
    await g_human_user_storage.remove_user()
}



//$>>	finalize_user_identity
// finalize_user_identity
// Once the application gets its user ucwid's, it calls finalize_user_identity 
// and this function stores the user values in the identity object in indexedDB.
//
async function finalize_user_identity(u_info,identity_files) {
    //
// "id" : ucwid with key,
// "clear_id" : ucwid without key,
// "dir_data" : user directory structure
    //
    let storage_obj = await identity_from_user(u_info)
    //
    let ucwid = value_fallback(identity_files.id)
    storage_obj.ucwid = ucwid
    storage_obj.dirs = value_fallback(value_fallback(identity_files.dir_data).dirs)
    storage_obj.files = value_fallback(value_fallback(identity_files.dir_data).files)
    storage_obj.stored_externally =  (ucwid.length > 0)
    //
    // UPDATE
    await g_human_user_storage.update_user(storage_obj)
}





//$>>	update_identity
async function update_identity(identity) {
    try {
        let u_info = identity.user_info
        let storage_obj = await identity_from_user(u_info)
        for ( let ky in storage_obj ) {
            if ( (ky == "dirs") || (ky === "files") ) {
                storage_obj[ky] = identity[ky]
            }
        }
        if ( identity.profile_image ) {
            storage_obj.profile_image = identity.profile_image
        }
        if ( identity.asset_keys ) {
            storage_obj.asset_keys = Object.assign({},identity.asset_keys)
        }
        if ( identity.introductions ) {
            storage_obj.introductions = identity.introductions
        }
        if ( identity.messages ) {
            storage_obj.messages = identity.messages
        }
        // UPDATE
        await g_human_user_storage.update_user(storage_obj)
        //
    } catch (e) {
    }
}

//$>>	restore_identity
async function restore_identity(identity) {
    try {
        await g_human_user_storage.add_user(identity)
    } catch (e) {
    }
}


//$>>	identity_from_user
async function identity_from_user(user_info) {
    let name_key = name_key_of(user_info)
    if ( !name_key ) return(false)
    //
    try {
       let identity = await g_human_user_storage.get_user(name_key)
       return identity
    } catch (e) {
    }
    return false
}



//$>>	fix_keys
async function fix_keys(identity) {
	let u_info = identity.user_info
	if ( !u_info ) return // can't fix it
	if ( ( identity.priv_key === undefined) || ( identity.signer_priv_key === undefined ) || ( u_info.signer_public_key === undefined ) ) {
		try {
			let storage_obj = await identity_from_user(u_info)
			if ( identity.priv_key === undefined ) {
				let keypair = await pc_wrapper_keypair_promise()
				// ---- ---- ---- ----
				let pub_key = keypair.publicKey
				let priv_key = keypair.privateKey
				let exported = await g_crypto.exportKey("jwk",pub_key);
				let pub_key_str = JSON.stringify(exported)

				let priv_exported = await g_crypto.exportKey("jwk",priv_key);
				let priv_key_str =  JSON.stringify(priv_exported);
				//
				storage_obj.priv_key = priv_key_str
				u_info.public_key = pub_key_str
			}
			//
			if ( ( identity.signer_priv_key === undefined ) || ( u_info.signer_public_key === undefined ) ) {
				let signer_pair = await pc_keypair_promise()
				//
				let signer_pub_key = signer_pair.publicKey
				let signer_priv_key = signer_pair.privateKey

				let sign_exported = await g_crypto.exportKey("jwk",signer_pub_key);
				let sign_pub_key_str = JSON.stringify(sign_exported)

				let sign_priv_exported = await g_crypto.exportKey("jwk",signer_priv_key);
				let sign_priv_key_str = JSON.stringify(sign_priv_exported);
				//
				storage_obj.signer_priv_key = sign_priv_key_str					
				u_info.signer_public_key = sign_pub_key_str
			}

            // UPDATE
            await g_human_user_storage.update_user(identity)
 
		} catch (e) {
		}
	}
}




//$>>	download_identity
var downloader_url = null
async function download_identity(user_info,remove) {
    //
    let downloadlink = document.getElementById("identity-download-link")
    if ( !(downloadlink) ) return false
    try {
        //
        let identity = await identity_from_user(user_info)
        let download_str = JSON.stringify(identity,null,4)

        let dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(download_str);

        let ext = ".json"
        let fname = identity.name_key

        downloadlink.setAttribute("href",     dataStr     );
        downloadlink.setAttribute("download", (fname + ext) );
        downloadlink.click();
        //
        if ( remove ) {
            await unstore_user(identity)
        }
    } catch (e) {}
}


//$>>	upload_identity
async function upload_identity() {
    let identity_str = await get_file()
    let identity = JSON.parse(identity_str)
    await restore_identity(identity)
    return identity
}


async function add_user_locally(id_packet) {
    //
/*
    let id_packet = {
        "user" : user_data,
        "keys" : keys,
        "original_cwid" : key_id_pair[0],
        "ucwid" :  key_id_pair[1]
    }
*/
    //
    return true
}



async function get_file() {
    return await get_file_from_file_element(`drop-click-file_loader`)
}

async function user_info_add_picture(fname,blob64) {
    // 
}

async function load_blob_as_url(img_ucwid) {
    //
}



// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//

// ---- parent_upload_identity
async function parent_upload_identity() {
    if ( window.parent ) {
        let upload_msg = {
            "direction" : MANAGER_PAGE_TO_FRAME,
            "relationship" : ID_MANAGER_ACTION_TO_FRAME,
            "category"  : FRAME_COMPONENT_MANAGE_ID,
            "action" : FRAME_ACTION_UPLOAD
        }
        const message = JSON.stringify(upload_msg);
        window.parent.postMessage(message, '*');
    }
}

// ---- app_download_identity
async function parent_download_identity() {
    if ( window.parent ) {
        let download_msg = {
            "direction" : MANAGER_PAGE_TO_FRAME,
            "relationship" : ID_MANAGER_ACTION_TO_FRAME,
            "category"  : FRAME_COMPONENT_MANAGE_ID,
            "action" : FRAME_ACTION_DOWNLOAD
        }
        const message = JSON.stringify(download_msg);
        window.parent.postMessage(message, '*');        
    }
}


async function parent_download_public_intro() {
    if ( window.parent ) {
        let download_msg = {
            "direction" : MANAGER_PAGE_TO_FRAME,
            "relationship" : ID_MANAGER_ACTION_TO_FRAME,
            "category"  : FRAME_COMPONENT_MANAGE_ID,
            "action" : FRAME_ACTION_DOWNLOAD_PUBLIC
        }
        const message = JSON.stringify(download_msg);
        window.parent.postMessage(message, '*');        
    }
}

// ---- tell_from_to_remove_identity
async function tell_parent_to_remove_identity() {
    if ( window.parent ) {
        let removal_msg = {
            "direction" : MANAGER_PAGE_TO_FRAME,
            "relationship" : ID_MANAGER_ACTION_TO_FRAME,
            "category"  : FRAME_COMPONENT_MANAGE_ID,
            "action" : FRAME_ACTION_REMOVE
        }
        const message = JSON.stringify(removal_msg);
        window.parent.postMessage(message, '*');        
    }
}




function tell_frame_profile_image(blob64) {
    if ( window.parent ) {
        let removal_msg = {
            "direction" : MANAGER_PAGE_TO_FRAME,
            "relationship" : ID_MANAGER_ACTION_TO_FRAME,
            "category"  : FRAME_MANAGE_PICTURE_ASSET,
            "action" : FRAME_ACTION_ATTACH,
            "image_url" : blob64
        }
        const message = JSON.stringify(removal_msg);
        window.parent.postMessage(message, '*');        
    }    
}



// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----


//$EXPORTABLE::
/*
db_startup
store_user
unstore_user
finalize_user_identity
update_identity
restore_identity
identity_from_user
get_known_users
get_user_public_wrapper_key
get_user_public_signer_key
fix_keys
*/


function set_user_title(u_name) {
	let el = document.getElementById('active-user-title')
	if ( el  && u_name && (typeof u_name === "string") ) {
		el.innerHTML = u_name
	}
}



// MODULE: USER WINDOW_APP (windowized)
//

// temporarily using pc_ prefix. There is a wv_ in a file "recorder.html"  that is for wave. This is for profile contacts.
// Later, these all should be wrapped in a class that handles generic use cases..
// Currently, this improper usage is contained in this file...


function hide_thankyou_box(theBox) {
	theBox.style.visibility = "hidden"
	theBox.style.display = "none";
	theBox.style.zIndex = 0
}

function show_thankyou_box(msg) {
	let theBox = document.querySelector("#thankyou_box")
	if ( theBox ) {
		if ( msg ) {
			let mbox = document.querySelector("#thankyou_box-message")
			if ( mbox ) mbox.innerHTML = msg

		}
		theBox.style.display = "block";
		theBox.style.visibility = "visible"
		theBox.style.zIndex = 2000
	}
}

//  === ---------------------------------------  === ---------------------------------------  === --------------------------------------- 


//  === ---------------------------------------  === ---------------------------------------  === --------------------------------------- 

// // // ----------------- // // // ----------------- // // // -----------------
// // // ----------------- // // // ----------------- // // // -----------------

// initial validation application is contact
g_CurContainer = null // will be initilialized within the finalizers

// EXTRA STUFF for some gracefull clicing
var the_thankyou_box = document.getElementById("thankyou_box");

// Get the <span> element that closes the modal
function setupCaptchaClose() {
	let closerList = document.getElementsByClassName("close");
	let n = closerList.length
	for ( let i = 0; i < n; i++ ) {
		let span = closerList[i]
		span.onclick = function() {
			if ( g_CurContainer ) g_CurContainer.switchCaptchaDisplay(false)
			if ( g_captaFinalResolution ) g_captaFinalResolution(3)
		}
	}
}


async function startup() {
	//await pc_init_database()
	//not_https_switch()
}

// independent floating box..





window._expose_to_page = false
window._add_console_data = false

function manager_ws_handler(message) {

    if ( message.ws_id ) {
            // check that its our connection
        message = message.data
    }

    if ( message.op === "proc-status") {
        let data = message.data
        let poc_list = []

        for ( let proc in data ) {
            poc_list.push(data[proc])
        }
        let future = [poc_list,data]

        if ( window._expose_to_page ) {
            window._expose_to_page(future)
        }
    } else if (message.op === "console-output" ) {
        if ( window._add_console_data ) {
            window._add_console_data(message)
        }
    }
}



var g_web_socket = null
function setup_webbsocekts() {
    try {
        // setup a webSocket connection to get finalization data on logging in. -- 
        g_web_socket = new WebSocket(`ws://${location.hostname}:8990`);
        g_web_socket.onmessage = (event) => {	// handle the finalization through the websocket
                try {
                    let message = JSON.parse(event.data)
                    manager_ws_handler(message)
                } catch (e) {
                    console.log(e)
                }
            }
        //
        return(true)       // prevent display of logout, etc until finalized
    } catch(e) {
        return(false)       // prevent display of logout, etc until finalized
    }   
}

setTimeout(setup_webbsocekts,2000)


async function fetch_procs_from_server() {
    let endpoint = `http://${location.host}/app/procs/`
    let data = await fetchUrl(endpoint)
    let poc_list = []
    for ( let proc in data ) {
        poc_list.push(data[proc])
    }
    return [poc_list,data]
}

async function post_proc_command(params) {

    let endpoint = `http://${location.host}/app/run-sys-op/`

    let result = await postData(endpoint,params)
    if ( result.status = "OK" ) {
        return true
    } else  { 
        return false
    }
}

async function fetch_app_config(config_file) {
    let file = encodeURIComponent(config_file)
    let endpoint = `http://${location.host}/app/get-config/` + file
    let data = await fetchUrl(endpoint)
    return data
}


</script>